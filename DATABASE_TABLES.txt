================================================================================
CAMPUS RESOURCE HUB - DATABASE SCHEMA DOCUMENTATION (OPTIMIZED)
================================================================================
Project: AI Driven Development (AiDD) 2025 Capstone
Database: SQLite 3.x
Total Tables: 20 (Optimized from 31 - removed 11 unused tables)
Schema Version: 2.0
Created: 2025-11-08
Last Updated: 2025-11-15

================================================================================
IMPORTANT: SCHEMA OPTIMIZATION NOTICE
================================================================================

This documentation reflects the OPTIMIZED database schema containing only the
20 ACTIVELY USED tables in the Campus Resource Hub application.

REMOVED TABLES (11 unused tables eliminated):
- admin_logs (redundant - no admin audit functionality implemented)
- ai_interactions (AI features not implemented in current scope)
- booking_recurrences (recurring bookings not implemented)
- calendar_events (external calendar sync not implemented)
- csrf_tokens (CSRF handled at application level)
- external_calendar_accounts (calendar integration not implemented)
- group_members (groups simplified - membership not tracked)
- rate_limits (rate limiting handled by web server)
- search_queries (search analytics not implemented)
- uploaded_files (file tracking not implemented)
- user_sessions (session management handled by Flask-Session)

The schema now focuses on core functionality that is actually implemented
and tested in the application.

================================================================================
TABLE OF CONTENTS
================================================================================

SECTION 1: CORE USER & ORGANIZATION TABLES (3 tables)
  1. users - User accounts and authentication
  2. departments - University departments
  3. groups - Teams and organizations

SECTION 2: RESOURCE MANAGEMENT TABLES (8 tables)
  4. resource_categories - Resource classification
  5. resources - Core resource listings
  6. resource_images - Resource photo galleries
  7. resource_equipment - Equipment associations
  8. resource_availability_rules - Availability schedules
  9. resource_unavailable_slots - Blackout periods
  10. resource_analytics - Usage statistics
  11. equipment - Equipment inventory

SECTION 3: BOOKING SYSTEM TABLES (3 tables)
  12. bookings - Reservation records
  13. booking_approval_actions - Approval audit trail
  14. booking_waitlist - Waitlist management

SECTION 4: COMMUNICATION TABLES (4 tables)
  15. message_threads - Conversation containers
  16. messages - Individual messages
  17. message_thread_participants - Thread membership
  18. notifications - Multi-channel alerts

SECTION 5: FEEDBACK & MODERATION TABLES (2 tables)
  19. reviews - User ratings and feedback
  20. content_reports - Content moderation system

================================================================================
SECTION 1: CORE USER & ORGANIZATION TABLES
================================================================================

--------------------------------------------------------------------------------
1. USERS TABLE
--------------------------------------------------------------------------------
Purpose: Core user authentication, profile management, and role-based access control

Schema:
CREATE TABLE users (
    user_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    role TEXT NOT NULL CHECK (role IN ('student','staff','admin')),
    profile_image TEXT,
    department_id INTEGER REFERENCES departments(department_id),
    email_verified BOOLEAN NOT NULL DEFAULT 0,
    verification_token TEXT,
    verification_token_expires DATETIME,
    reset_password_token TEXT,
    reset_password_expires DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME,
    is_banned INTEGER DEFAULT 0,
    last_login TIMESTAMP
);

Columns:
- user_id: Unique identifier, auto-incremented
- name: User's display name (required)
- email: Unique email address for authentication (required)
- password_hash: Bcrypt-hashed password (never store plain text)
- role: Access level - 'student', 'staff', or 'admin'
- profile_image: Path to user's profile photo (optional)
- department_id: Foreign key to departments table
- email_verified: Boolean flag for email verification status
- verification_token: Token for email verification process
- verification_token_expires: Expiration time for verification token
- reset_password_token: Token for password reset process
- reset_password_expires: Expiration time for password reset
- created_at: Account creation timestamp
- updated_at: Last profile update timestamp
- is_banned: Flag for banned users (0=active, 1=banned)
- last_login: Timestamp of most recent login

Primary Key: user_id
Foreign Keys: department_id ‚Üí departments(department_id)
Indexes:
- idx_users_email ON users(email) - Fast email lookups for login
- idx_users_role ON users(role) - Filter users by role

Business Logic:
- Email must be unique across all users
- Password stored as bcrypt hash with salt
- Verification tokens expire after 24 hours
- Reset tokens expire after 1 hour
- Role determines access to admin features

Example Queries:
-- Authenticate user
SELECT user_id, password_hash, role FROM users
WHERE email = ? AND is_banned = 0;

-- Get user profile with department
SELECT u.*, d.name as department_name
FROM users u
LEFT JOIN departments d ON u.department_id = d.department_id
WHERE u.user_id = ?;

-- Find unverified accounts older than 7 days
SELECT * FROM users
WHERE email_verified = 0
AND created_at < datetime('now', '-7 days');

--------------------------------------------------------------------------------
2. DEPARTMENTS TABLE
--------------------------------------------------------------------------------
Purpose: Organize users by university departments for filtering and analytics

Schema:
CREATE TABLE departments (
    department_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Columns:
- department_id: Unique identifier, auto-incremented
- name: Department name (e.g., "School of Informatics")
- description: Optional detailed description
- created_at: Record creation timestamp

Primary Key: department_id
Foreign Keys: None (referenced by users table)
Indexes: None additional (primary key indexed automatically)

Business Logic:
- Departments are created by admins
- Cannot delete department with active users
- Used for filtering resources and analytics

Example Queries:
-- List all departments with user counts
SELECT d.*, COUNT(u.user_id) as user_count
FROM departments d
LEFT JOIN users u ON d.department_id = u.department_id
GROUP BY d.department_id
ORDER BY d.name;

-- Get department resources
SELECT r.* FROM resources r
JOIN users u ON r.owner_id = u.user_id AND r.owner_type = 'user'
WHERE u.department_id = ?;

Seed Data:
- Kelley School of Business
- School of Informatics
- College of Engineering
- School of Medicine
- School of Law
- School of Education
- College of Arts and Sciences
- School of Public Health

--------------------------------------------------------------------------------
3. GROUPS TABLE
--------------------------------------------------------------------------------
Purpose: Teams, clubs, or organizations that can collectively own resources

Schema:
CREATE TABLE groups (
    group_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    created_by INTEGER NOT NULL REFERENCES users(user_id),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Columns:
- group_id: Unique identifier, auto-incremented
- name: Group name (e.g., "Computer Science Club")
- description: Group purpose and details
- created_by: User who created the group (admin/owner)
- created_at: Group creation timestamp

Primary Key: group_id
Foreign Keys: created_by ‚Üí users(user_id)
Indexes: None additional

Business Logic:
- Groups can own resources (via resources.owner_type='group')
- Creator becomes default group admin
- Groups simplify resource sharing for teams
- No explicit membership tracking in optimized schema

Example Queries:
-- Get groups created by a user
SELECT * FROM groups WHERE created_by = ? ORDER BY created_at DESC;

-- Get all resources owned by a group
SELECT r.* FROM resources r
WHERE r.owner_type = 'group' AND r.owner_id = ?;

-- Count resources per group
SELECT g.*, COUNT(r.resource_id) as resource_count
FROM groups g
LEFT JOIN resources r ON r.owner_type = 'group' AND r.owner_id = g.group_id
GROUP BY g.group_id;

================================================================================
SECTION 2: RESOURCE MANAGEMENT TABLES
================================================================================

--------------------------------------------------------------------------------
4. RESOURCE_CATEGORIES TABLE
--------------------------------------------------------------------------------
Purpose: Classify resources into searchable categories with icons

Schema:
CREATE TABLE resource_categories (
    category_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Columns:
- category_id: Unique identifier, auto-incremented
- name: Category name (e.g., "Study Rooms")
- description: Detailed category description
- icon: Icon class or emoji for UI display
- created_at: Category creation timestamp

Primary Key: category_id
Foreign Keys: None (referenced by resources table)
Indexes: None additional

Business Logic:
- Categories enable filtered search
- Icons improve UI navigation
- Cannot delete category with active resources

Example Queries:
-- Get categories with resource counts
SELECT rc.*, COUNT(r.resource_id) as resource_count
FROM resource_categories rc
LEFT JOIN resources r ON rc.category_id = r.category_id
GROUP BY rc.category_id
ORDER BY rc.name;

-- Get popular categories
SELECT rc.*, COUNT(b.booking_id) as total_bookings
FROM resource_categories rc
JOIN resources r ON rc.category_id = r.category_id
LEFT JOIN bookings b ON r.resource_id = b.resource_id
WHERE b.created_at > datetime('now', '-30 days')
GROUP BY rc.category_id
ORDER BY total_bookings DESC;

Seed Data:
- Study Rooms (üìö)
- Computer Labs (üíª)
- AV Equipment (üìπ)
- Lab Instruments (üî¨)
- Meeting Rooms (üë•)
- Event Spaces (üé™)
- Sports Facilities (‚öΩ)
- Parking Spaces (üöó)

--------------------------------------------------------------------------------
5. RESOURCES TABLE
--------------------------------------------------------------------------------
Purpose: Core resource listings with polymorphic ownership and availability modes

Schema:
CREATE TABLE resources (
    resource_id INTEGER PRIMARY KEY AUTOINCREMENT,
    owner_type TEXT NOT NULL CHECK (owner_type IN ('user','group')),
    owner_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    category_id INTEGER REFERENCES resource_categories(category_id),
    location TEXT,
    capacity INTEGER CHECK (capacity > 0 OR capacity IS NULL),
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft','published','archived')),
    availability_mode TEXT NOT NULL DEFAULT 'rules' CHECK (availability_mode IN ('rules','open','by-request')),
    requires_approval BOOLEAN NOT NULL DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME,
    images TEXT,
    availability_rules TEXT
);

Columns:
- resource_id: Unique identifier, auto-incremented
- owner_type: 'user' or 'group' (polymorphic relationship)
- owner_id: References user_id or group_id based on owner_type
- title: Resource name/title (required)
- description: Detailed resource description
- category_id: Foreign key to resource_categories
- location: Physical location or room number
- capacity: Maximum capacity (NULL for single items)
- status: 'draft', 'published', or 'archived'
- availability_mode: 'rules', 'open', or 'by-request'
- requires_approval: Boolean for approval workflow
- created_at: Resource creation timestamp
- updated_at: Last modification timestamp
- images: JSON array of image paths (denormalized for performance)
- availability_rules: JSON rules (denormalized for performance)

Primary Key: resource_id
Foreign Keys:
- category_id ‚Üí resource_categories(category_id)
- Polymorphic: owner_id ‚Üí users(user_id) OR groups(group_id)

Indexes:
- idx_resources_category ON resources(category_id)
- idx_resources_owner ON resources(owner_type, owner_id)
- idx_resources_status ON resources(status)

Business Logic:
- Polymorphic ownership allows user or group ownership
- Capacity NULL for single items (e.g., one laptop)
- Status workflow: draft ‚Üí published ‚Üí archived
- Availability modes determine booking rules
- Approval required triggers approval workflow

Example Queries:
-- Get all published resources with owner details
SELECT r.*,
       CASE
         WHEN r.owner_type = 'user' THEN u.name
         WHEN r.owner_type = 'group' THEN g.name
       END as owner_name
FROM resources r
LEFT JOIN users u ON r.owner_type = 'user' AND r.owner_id = u.user_id
LEFT JOIN groups g ON r.owner_type = 'group' AND r.owner_id = g.group_id
WHERE r.status = 'published';

-- Search resources by keyword and category
SELECT r.*, rc.name as category_name, rc.icon
FROM resources r
JOIN resource_categories rc ON r.category_id = rc.category_id
WHERE r.status = 'published'
AND (r.title LIKE ? OR r.description LIKE ?)
AND r.category_id = ?
ORDER BY r.title;

-- Get available resources for time slot
SELECT DISTINCT r.*
FROM resources r
WHERE r.status = 'published'
AND r.resource_id NOT IN (
    SELECT resource_id FROM bookings
    WHERE status IN ('approved', 'pending')
    AND start_datetime < ?
    AND end_datetime > ?
)
AND r.resource_id NOT IN (
    SELECT resource_id FROM resource_unavailable_slots
    WHERE start_datetime < ?
    AND end_datetime > ?
);

--------------------------------------------------------------------------------
6. RESOURCE_IMAGES TABLE
--------------------------------------------------------------------------------
Purpose: Multiple images per resource with ordering and primary image support

Schema:
CREATE TABLE resource_images (
    image_id INTEGER PRIMARY KEY AUTOINCREMENT,
    resource_id INTEGER NOT NULL REFERENCES resources(resource_id) ON DELETE CASCADE,
    image_path TEXT NOT NULL,
    is_primary BOOLEAN NOT NULL DEFAULT 0,
    sort_order INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Columns:
- image_id: Unique identifier, auto-incremented
- resource_id: Foreign key to resources table
- image_path: File path or URL to image
- is_primary: Boolean flag for main display image
- sort_order: Integer for gallery ordering
- created_at: Image upload timestamp

Primary Key: image_id
Foreign Keys: resource_id ‚Üí resources(resource_id) ON DELETE CASCADE
Indexes: Automatic index on resource_id (foreign key)

Business Logic:
- Only one image per resource should have is_primary = 1
- Images displayed in sort_order ascending
- CASCADE DELETE removes images when resource deleted
- Support for image carousel in UI

Example Queries:
-- Get primary image for resources
SELECT r.resource_id, r.title, ri.image_path
FROM resources r
LEFT JOIN resource_images ri ON r.resource_id = ri.resource_id AND ri.is_primary = 1
WHERE r.status = 'published';

-- Get all images for a resource in order
SELECT * FROM resource_images
WHERE resource_id = ?
ORDER BY is_primary DESC, sort_order ASC;

-- Update primary image
UPDATE resource_images SET is_primary = 0 WHERE resource_id = ?;
UPDATE resource_images SET is_primary = 1 WHERE image_id = ?;

--------------------------------------------------------------------------------
7. RESOURCE_EQUIPMENT TABLE
--------------------------------------------------------------------------------
Purpose: Many-to-many relationship between resources and equipment with status tracking

Schema:
CREATE TABLE resource_equipment (
    resource_id INTEGER NOT NULL REFERENCES resources(resource_id) ON DELETE CASCADE,
    equipment_id INTEGER NOT NULL REFERENCES equipment(equipment_id) ON DELETE CASCADE,
    quantity INTEGER DEFAULT 1,
    status TEXT DEFAULT 'available' CHECK (status IN ('available','in_use','maintenance','broken')),
    last_checked DATETIME,
    PRIMARY KEY (resource_id, equipment_id)
);

Columns:
- resource_id: Foreign key to resources table
- equipment_id: Foreign key to equipment table
- quantity: Number of this equipment type
- status: Current condition of equipment
- last_checked: Last maintenance check timestamp

Primary Key: Composite (resource_id, equipment_id)
Foreign Keys:
- resource_id ‚Üí resources(resource_id) ON DELETE CASCADE
- equipment_id ‚Üí equipment(equipment_id) ON DELETE CASCADE
Indexes: Automatic on composite primary key

Business Logic:
- Track equipment condition per resource location
- Same equipment model may have different status in different rooms
- Maintenance workflows update status field
- last_checked tracks inspection dates

Example Queries:
-- Get all equipment for a resource
SELECT e.*, re.quantity, re.status, re.last_checked
FROM resource_equipment re
JOIN equipment e ON re.equipment_id = e.equipment_id
WHERE re.resource_id = ?
ORDER BY e.name;

-- Find resources with specific equipment
SELECT r.* FROM resources r
JOIN resource_equipment re ON r.resource_id = re.resource_id
WHERE re.equipment_id = ?
AND re.status = 'available'
AND r.status = 'published';

-- Maintenance report - broken equipment
SELECT r.title, r.location, e.name, re.last_checked
FROM resource_equipment re
JOIN resources r ON re.resource_id = r.resource_id
JOIN equipment e ON re.equipment_id = e.equipment_id
WHERE re.status = 'broken'
ORDER BY re.last_checked DESC;

--------------------------------------------------------------------------------
8. RESOURCE_AVAILABILITY_RULES TABLE
--------------------------------------------------------------------------------
Purpose: Define recurring availability patterns using JSON rules

Schema:
CREATE TABLE resource_availability_rules (
    rule_id INTEGER PRIMARY KEY AUTOINCREMENT,
    resource_id INTEGER NOT NULL REFERENCES resources(resource_id) ON DELETE CASCADE,
    rule_json TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME
);

Columns:
- rule_id: Unique identifier, auto-incremented
- resource_id: Foreign key to resources table
- rule_json: JSON-encoded availability rules
- created_at: Rule creation timestamp
- updated_at: Last rule modification timestamp

Primary Key: rule_id
Foreign Keys: resource_id ‚Üí resources(resource_id) ON DELETE CASCADE
Indexes: Automatic index on resource_id

Business Logic:
- JSON rules define weekly patterns
- Support for different weekday/weekend hours
- Rules parsed by application layer
- Multiple rules can be combined

Example JSON Rule Format:
{
    "monday": {"start": "09:00", "end": "17:00"},
    "tuesday": {"start": "09:00", "end": "17:00"},
    "wednesday": {"start": "09:00", "end": "17:00"},
    "thursday": {"start": "09:00", "end": "17:00"},
    "friday": {"start": "09:00", "end": "15:00"},
    "saturday": {"start": "10:00", "end": "14:00"},
    "sunday": "closed",
    "exceptions": {
        "2025-12-25": "closed",
        "2025-01-01": "closed"
    }
}

Example Queries:
-- Get availability rules for a resource
SELECT rule_json FROM resource_availability_rules
WHERE resource_id = ?
ORDER BY created_at DESC
LIMIT 1;

-- Find resources available on weekends
SELECT r.* FROM resources r
JOIN resource_availability_rules rar ON r.resource_id = rar.resource_id
WHERE r.status = 'published'
AND (rar.rule_json LIKE '%"saturday"%' AND rar.rule_json NOT LIKE '%"saturday":"closed"%');

--------------------------------------------------------------------------------
9. RESOURCE_UNAVAILABLE_SLOTS TABLE
--------------------------------------------------------------------------------
Purpose: Define blackout periods for maintenance, holidays, or special events

Schema:
CREATE TABLE resource_unavailable_slots (
    slot_id INTEGER PRIMARY KEY AUTOINCREMENT,
    resource_id INTEGER NOT NULL REFERENCES resources(resource_id) ON DELETE CASCADE,
    start_datetime DATETIME NOT NULL,
    end_datetime DATETIME NOT NULL,
    reason TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    CHECK (end_datetime > start_datetime)
);

Columns:
- slot_id: Unique identifier, auto-incremented
- resource_id: Foreign key to resources table
- start_datetime: Unavailability start time
- end_datetime: Unavailability end time
- reason: Optional explanation for unavailability
- created_at: Record creation timestamp

Primary Key: slot_id
Foreign Keys: resource_id ‚Üí resources(resource_id) ON DELETE CASCADE
Indexes: Composite index on (resource_id, start_datetime, end_datetime)

Business Logic:
- Prevents bookings during unavailable periods
- CHECK constraint ensures valid time ranges
- Used for maintenance windows and holidays
- Override regular availability rules

Example Queries:
-- Check if resource is available for time slot
SELECT COUNT(*) as conflicts FROM resource_unavailable_slots
WHERE resource_id = ?
AND start_datetime < ?
AND end_datetime > ?;

-- Get upcoming maintenance windows
SELECT r.title, rus.start_datetime, rus.end_datetime, rus.reason
FROM resource_unavailable_slots rus
JOIN resources r ON rus.resource_id = r.resource_id
WHERE rus.start_datetime > datetime('now')
AND rus.reason LIKE '%maintenance%'
ORDER BY rus.start_datetime;

-- Mark resource unavailable for maintenance
INSERT INTO resource_unavailable_slots (resource_id, start_datetime, end_datetime, reason)
VALUES (?, ?, ?, 'Scheduled maintenance - Deep cleaning');

--------------------------------------------------------------------------------
10. RESOURCE_ANALYTICS TABLE
--------------------------------------------------------------------------------
Purpose: Track daily usage metrics for resources to support data-driven decisions

Schema:
CREATE TABLE resource_analytics (
    analytics_id INTEGER PRIMARY KEY AUTOINCREMENT,
    resource_id INTEGER NOT NULL REFERENCES resources(resource_id) ON DELETE CASCADE,
    date DATE NOT NULL,
    total_bookings INTEGER DEFAULT 0,
    total_hours_booked REAL DEFAULT 0,
    unique_users INTEGER DEFAULT 0,
    avg_rating REAL,
    utilization_rate REAL,
    revenue REAL DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(resource_id, date)
);

Columns:
- analytics_id: Unique identifier, auto-incremented
- resource_id: Foreign key to resources table
- date: Date for these metrics (YYYY-MM-DD)
- total_bookings: Number of bookings on this date
- total_hours_booked: Sum of booking durations
- unique_users: Distinct users who booked
- avg_rating: Average review rating for this date
- utilization_rate: Percentage of available time booked
- revenue: Total revenue if applicable
- created_at: Record creation timestamp

Primary Key: analytics_id
Foreign Keys: resource_id ‚Üí resources(resource_id) ON DELETE CASCADE
Unique Constraint: (resource_id, date) - One record per resource per day
Indexes: Automatic on unique constraint

Business Logic:
- Aggregated nightly from bookings and reviews
- Utilization rate = hours_booked / hours_available
- Support for revenue tracking (future feature)
- Historical data for trend analysis

Example Queries:
-- Get monthly analytics for a resource
SELECT
    strftime('%Y-%m', date) as month,
    SUM(total_bookings) as monthly_bookings,
    SUM(total_hours_booked) as monthly_hours,
    AVG(utilization_rate) as avg_utilization,
    AVG(avg_rating) as avg_rating
FROM resource_analytics
WHERE resource_id = ?
AND date >= datetime('now', '-6 months')
GROUP BY month
ORDER BY month DESC;

-- Find underutilized resources
SELECT r.title, AVG(ra.utilization_rate) as avg_utilization
FROM resources r
JOIN resource_analytics ra ON r.resource_id = ra.resource_id
WHERE ra.date >= datetime('now', '-30 days')
GROUP BY r.resource_id
HAVING avg_utilization < 0.3
ORDER BY avg_utilization ASC;

-- Top resources by unique users
SELECT r.title, SUM(ra.unique_users) as total_unique_users
FROM resources r
JOIN resource_analytics ra ON r.resource_id = ra.resource_id
WHERE ra.date >= datetime('now', '-7 days')
GROUP BY r.resource_id
ORDER BY total_unique_users DESC
LIMIT 10;

--------------------------------------------------------------------------------
11. EQUIPMENT TABLE
--------------------------------------------------------------------------------
Purpose: Master list of equipment types that can be associated with resources

Schema:
CREATE TABLE equipment (
    equipment_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Columns:
- equipment_id: Unique identifier, auto-incremented
- name: Equipment name (e.g., "Projector", "Whiteboard")
- description: Detailed equipment specifications
- created_at: Record creation timestamp

Primary Key: equipment_id
Foreign Keys: None (referenced by resource_equipment)
Indexes: None additional

Business Logic:
- Reusable equipment definitions
- Many-to-many with resources via resource_equipment
- Centralized equipment management
- Cannot delete if associated with resources

Example Queries:
-- List all equipment with usage counts
SELECT e.*, COUNT(DISTINCT re.resource_id) as resource_count
FROM equipment e
LEFT JOIN resource_equipment re ON e.equipment_id = re.equipment_id
GROUP BY e.equipment_id
ORDER BY e.name;

-- Find unused equipment
SELECT * FROM equipment
WHERE equipment_id NOT IN (
    SELECT DISTINCT equipment_id FROM resource_equipment
);

Seed Data Examples:
- Projector
- Whiteboard
- Smart TV
- Video Camera
- Microphone System
- Computer Workstation
- 3D Printer
- Laboratory Microscope

================================================================================
SECTION 3: BOOKING SYSTEM TABLES
================================================================================

--------------------------------------------------------------------------------
12. BOOKINGS TABLE
--------------------------------------------------------------------------------
Purpose: Core reservation system for resources with approval workflow support

Schema:
CREATE TABLE bookings (
    booking_id INTEGER PRIMARY KEY AUTOINCREMENT,
    resource_id INTEGER NOT NULL REFERENCES resources(resource_id) ON DELETE RESTRICT,
    requester_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE RESTRICT,
    start_datetime DATETIME NOT NULL,
    end_datetime DATETIME NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending','approved','rejected','cancelled','completed')),
    approval_required BOOLEAN NOT NULL DEFAULT 0,
    notes TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME,
    CHECK (end_datetime > start_datetime)
);

Columns:
- booking_id: Unique identifier, auto-incremented
- resource_id: Foreign key to resources table
- requester_id: Foreign key to users table (who made booking)
- start_datetime: Booking start time
- end_datetime: Booking end time
- status: Booking state in workflow
- approval_required: Whether approval needed
- notes: Optional booking notes/purpose
- created_at: Booking creation timestamp
- updated_at: Last status change timestamp

Primary Key: booking_id
Foreign Keys:
- resource_id ‚Üí resources(resource_id) ON DELETE RESTRICT
- requester_id ‚Üí users(user_id) ON DELETE RESTRICT
Constraints: CHECK (end_datetime > start_datetime)

Indexes:
- idx_bookings_resource ON bookings(resource_id)
- idx_bookings_user ON bookings(requester_id)
- idx_bookings_status ON bookings(status)
- idx_bookings_dates ON bookings(start_datetime, end_datetime)

Business Logic:
- Status workflow: pending ‚Üí approved/rejected ‚Üí completed/cancelled
- RESTRICT deletion prevents orphaned bookings
- Approval required inherits from resource settings
- Conflict detection via date overlap queries

Example Queries:
-- Check for booking conflicts
SELECT COUNT(*) as conflicts FROM bookings
WHERE resource_id = ?
AND status IN ('approved', 'pending')
AND start_datetime < ?
AND end_datetime > ?;

-- Get user's upcoming bookings
SELECT b.*, r.title, r.location
FROM bookings b
JOIN resources r ON b.resource_id = r.resource_id
WHERE b.requester_id = ?
AND b.start_datetime > datetime('now')
AND b.status IN ('approved', 'pending')
ORDER BY b.start_datetime;

-- Get pending approvals for resource owner
SELECT b.*, u.name as requester_name, u.email
FROM bookings b
JOIN users u ON b.requester_id = u.user_id
JOIN resources r ON b.resource_id = r.resource_id
WHERE r.owner_type = 'user' AND r.owner_id = ?
AND b.status = 'pending'
AND b.approval_required = 1
ORDER BY b.created_at;

-- Calculate resource utilization
SELECT
    r.title,
    COUNT(b.booking_id) as total_bookings,
    SUM((julianday(b.end_datetime) - julianday(b.start_datetime)) * 24) as total_hours
FROM resources r
LEFT JOIN bookings b ON r.resource_id = b.resource_id
WHERE b.status = 'completed'
AND b.start_datetime >= datetime('now', '-30 days')
GROUP BY r.resource_id;

--------------------------------------------------------------------------------
13. BOOKING_APPROVAL_ACTIONS TABLE
--------------------------------------------------------------------------------
Purpose: Audit trail for all booking approval decisions

Schema:
CREATE TABLE booking_approval_actions (
    approval_id INTEGER PRIMARY KEY AUTOINCREMENT,
    booking_id INTEGER NOT NULL REFERENCES bookings(booking_id) ON DELETE CASCADE,
    approver_id INTEGER NOT NULL REFERENCES users(user_id),
    action TEXT NOT NULL CHECK (action IN ('approved','rejected')),
    comment TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Columns:
- approval_id: Unique identifier, auto-incremented
- booking_id: Foreign key to bookings table
- approver_id: User who took the action
- action: 'approved' or 'rejected'
- comment: Optional explanation for decision
- created_at: Action timestamp

Primary Key: approval_id
Foreign Keys:
- booking_id ‚Üí bookings(booking_id) ON DELETE CASCADE
- approver_id ‚Üí users(user_id)
Indexes: Automatic on foreign keys

Business Logic:
- Creates immutable audit trail
- CASCADE DELETE with booking deletion
- One record per approval action
- Support for approval comments/reasons

Example Queries:
-- Get approval history for a booking
SELECT baa.*, u.name as approver_name
FROM booking_approval_actions baa
JOIN users u ON baa.approver_id = u.user_id
WHERE baa.booking_id = ?
ORDER BY baa.created_at DESC;

-- Approver activity report
SELECT
    u.name,
    COUNT(CASE WHEN baa.action = 'approved' THEN 1 END) as approved_count,
    COUNT(CASE WHEN baa.action = 'rejected' THEN 1 END) as rejected_count
FROM booking_approval_actions baa
JOIN users u ON baa.approver_id = u.user_id
WHERE baa.created_at >= datetime('now', '-30 days')
GROUP BY baa.approver_id;

-- Record approval action
INSERT INTO booking_approval_actions (booking_id, approver_id, action, comment)
VALUES (?, ?, 'approved', 'Confirmed availability with department');

--------------------------------------------------------------------------------
14. BOOKING_WAITLIST TABLE
--------------------------------------------------------------------------------
Purpose: Manage waitlists for fully booked resources with notification system

Schema:
CREATE TABLE booking_waitlist (
    waitlist_id INTEGER PRIMARY KEY AUTOINCREMENT,
    resource_id INTEGER NOT NULL REFERENCES resources(resource_id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    desired_start_datetime DATETIME NOT NULL,
    desired_end_datetime DATETIME NOT NULL,
    status TEXT NOT NULL DEFAULT 'waiting' CHECK (status IN ('waiting','notified','converted','cancelled')),
    converted_booking_id INTEGER REFERENCES bookings(booking_id),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    notified_at DATETIME,
    CHECK (desired_end_datetime > desired_start_datetime)
);

Columns:
- waitlist_id: Unique identifier, auto-incremented
- resource_id: Resource user is waiting for
- user_id: User on the waitlist
- desired_start_datetime: Requested start time
- desired_end_datetime: Requested end time
- status: Waitlist entry state
- converted_booking_id: If converted to booking
- created_at: Waitlist entry creation
- notified_at: When user was notified of availability

Primary Key: waitlist_id
Foreign Keys:
- resource_id ‚Üí resources(resource_id) ON DELETE CASCADE
- user_id ‚Üí users(user_id) ON DELETE CASCADE
- converted_booking_id ‚Üí bookings(booking_id)
Constraints: CHECK (desired_end_datetime > desired_start_datetime)

Business Logic:
- Status workflow: waiting ‚Üí notified ‚Üí converted/cancelled
- Notify when matching slot becomes available
- FIFO processing within time windows
- Auto-cancel if not converted within timeout

Example Queries:
-- Get waitlist for a resource
SELECT w.*, u.name, u.email
FROM booking_waitlist w
JOIN users u ON w.user_id = u.user_id
WHERE w.resource_id = ?
AND w.status = 'waiting'
ORDER BY w.created_at;

-- Find waitlist entries to notify (booking cancelled)
SELECT * FROM booking_waitlist
WHERE resource_id = ?
AND status = 'waiting'
AND desired_start_datetime <= ?
AND desired_end_datetime >= ?
ORDER BY created_at
LIMIT 5;

-- Convert waitlist to booking
UPDATE booking_waitlist
SET status = 'converted',
    converted_booking_id = ?
WHERE waitlist_id = ?;

-- Waitlist conversion rate
SELECT
    COUNT(*) as total_waitlist,
    COUNT(CASE WHEN status = 'converted' THEN 1 END) as converted,
    ROUND(100.0 * COUNT(CASE WHEN status = 'converted' THEN 1 END) / COUNT(*), 2) as conversion_rate
FROM booking_waitlist
WHERE created_at >= datetime('now', '-30 days');

================================================================================
SECTION 4: COMMUNICATION TABLES
================================================================================

--------------------------------------------------------------------------------
15. MESSAGE_THREADS TABLE
--------------------------------------------------------------------------------
Purpose: Container for conversations between users about resources or bookings

Schema:
CREATE TABLE message_threads (
    thread_id INTEGER PRIMARY KEY AUTOINCREMENT,
    resource_id INTEGER REFERENCES resources(resource_id) ON DELETE SET NULL,
    booking_id INTEGER REFERENCES bookings(booking_id) ON DELETE SET NULL,
    subject TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME
);

Columns:
- thread_id: Unique identifier, auto-incremented
- resource_id: Optional link to resource
- booking_id: Optional link to booking
- subject: Thread subject/title
- created_at: Thread creation timestamp
- updated_at: Last message timestamp

Primary Key: thread_id
Foreign Keys:
- resource_id ‚Üí resources(resource_id) ON DELETE SET NULL
- booking_id ‚Üí bookings(booking_id) ON DELETE SET NULL
Indexes: Automatic on foreign keys

Business Logic:
- Threads can be about resources, bookings, or general
- SET NULL preserves thread if resource/booking deleted
- updated_at refreshed on new message
- Support for multi-party conversations

Example Queries:
-- Get user's message threads
SELECT DISTINCT mt.*,
       COUNT(m.message_id) as message_count,
       MAX(m.sent_at) as last_message_time
FROM message_threads mt
JOIN message_thread_participants mtp ON mt.thread_id = mtp.thread_id
LEFT JOIN messages m ON mt.thread_id = m.thread_id
WHERE mtp.user_id = ?
GROUP BY mt.thread_id
ORDER BY last_message_time DESC;

-- Get threads about a resource
SELECT mt.*, r.title as resource_title
FROM message_threads mt
JOIN resources r ON mt.resource_id = r.resource_id
WHERE mt.resource_id = ?
ORDER BY mt.updated_at DESC;

--------------------------------------------------------------------------------
16. MESSAGES TABLE
--------------------------------------------------------------------------------
Purpose: Individual messages within conversation threads

Schema:
CREATE TABLE messages (
    message_id INTEGER PRIMARY KEY AUTOINCREMENT,
    thread_id INTEGER NOT NULL REFERENCES message_threads(thread_id) ON DELETE CASCADE,
    sender_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    receiver_id INTEGER REFERENCES users(user_id) ON DELETE SET NULL,
    content TEXT NOT NULL,
    is_read BOOLEAN NOT NULL DEFAULT 0,
    sent_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Columns:
- message_id: Unique identifier, auto-incremented
- thread_id: Foreign key to message thread
- sender_id: User who sent the message
- receiver_id: Optional specific recipient
- content: Message text content
- is_read: Read status flag
- sent_at: Message timestamp

Primary Key: message_id
Foreign Keys:
- thread_id ‚Üí message_threads(thread_id) ON DELETE CASCADE
- sender_id ‚Üí users(user_id) ON DELETE CASCADE
- receiver_id ‚Üí users(user_id) ON DELETE SET NULL

Indexes:
- idx_messages_thread ON messages(thread_id)
- idx_messages_sender ON messages(sender_id)

Business Logic:
- CASCADE DELETE with thread deletion
- Soft delete via SET NULL for receiver
- is_read tracks per-message read status
- Support for broadcast (receiver_id NULL)

Example Queries:
-- Get messages in a thread
SELECT m.*,
       s.name as sender_name,
       s.profile_image as sender_image
FROM messages m
JOIN users s ON m.sender_id = s.user_id
WHERE m.thread_id = ?
ORDER BY m.sent_at;

-- Count unread messages for user
SELECT COUNT(*) as unread_count
FROM messages m
JOIN message_thread_participants mtp ON m.thread_id = mtp.thread_id
WHERE mtp.user_id = ?
AND m.sender_id != ?
AND m.is_read = 0;

-- Mark thread as read
UPDATE messages
SET is_read = 1
WHERE thread_id = ?
AND receiver_id = ?
AND is_read = 0;

--------------------------------------------------------------------------------
17. MESSAGE_THREAD_PARTICIPANTS TABLE
--------------------------------------------------------------------------------
Purpose: Track which users are part of each message thread

Schema:
CREATE TABLE message_thread_participants (
    thread_id INTEGER NOT NULL REFERENCES message_threads(thread_id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_read_at DATETIME,
    PRIMARY KEY (thread_id, user_id)
);

Columns:
- thread_id: Foreign key to message thread
- user_id: Foreign key to participant user
- joined_at: When user joined thread
- last_read_at: Last time user viewed thread

Primary Key: Composite (thread_id, user_id)
Foreign Keys:
- thread_id ‚Üí message_threads(thread_id) ON DELETE CASCADE
- user_id ‚Üí users(user_id) ON DELETE CASCADE
Indexes: Automatic on composite primary key

Business Logic:
- Defines thread membership
- Supports multi-party conversations
- last_read_at for unread indicators
- CASCADE DELETE maintains integrity

Example Queries:
-- Get participants in a thread
SELECT u.user_id, u.name, u.profile_image, mtp.joined_at
FROM message_thread_participants mtp
JOIN users u ON mtp.user_id = u.user_id
WHERE mtp.thread_id = ?
ORDER BY mtp.joined_at;

-- Find common threads between two users
SELECT thread_id FROM message_thread_participants
WHERE user_id = ?
INTERSECT
SELECT thread_id FROM message_thread_participants
WHERE user_id = ?;

-- Add user to thread
INSERT INTO message_thread_participants (thread_id, user_id)
VALUES (?, ?);

--------------------------------------------------------------------------------
18. NOTIFICATIONS TABLE
--------------------------------------------------------------------------------
Purpose: Multi-channel notification system for events and communications

Schema:
CREATE TABLE notifications (
    notification_id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    notification_type TEXT NOT NULL CHECK (notification_type IN (
        'booking_requested','booking_approved','booking_rejected',
        'booking_cancelled','waitlist_notified','message_received',
        'review_posted','resource_available'
    )),
    payload_json TEXT,
    delivery_method TEXT DEFAULT 'in_app' CHECK (delivery_method IN ('in_app','email','sms','push')),
    delivery_status TEXT DEFAULT 'pending' CHECK (delivery_status IN ('pending','sent','failed')),
    is_read BOOLEAN NOT NULL DEFAULT 0,
    sent_at DATETIME,
    error_message TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Columns:
- notification_id: Unique identifier, auto-incremented
- user_id: Recipient user
- notification_type: Type of notification
- payload_json: JSON data for notification
- delivery_method: How to deliver notification
- delivery_status: Delivery state
- is_read: Read status for in-app notifications
- sent_at: When notification was sent
- error_message: Error if delivery failed
- created_at: Notification creation timestamp

Primary Key: notification_id
Foreign Keys: user_id ‚Üí users(user_id) ON DELETE CASCADE

Indexes:
- idx_notifications_user ON notifications(user_id)
- idx_notifications_read ON notifications(is_read)

Business Logic:
- Multiple delivery channels supported
- Retry logic for failed deliveries
- JSON payload for flexible data
- Read tracking for in-app notifications

Notification Types:
- booking_requested: Owner receives booking request
- booking_approved: Requester notified of approval
- booking_rejected: Requester notified of rejection
- booking_cancelled: Relevant parties notified
- waitlist_notified: Waitlist user notified of opening
- message_received: New message in thread
- review_posted: Owner receives new review
- resource_available: Resource becomes available

Example Queries:
-- Get user's unread notifications
SELECT * FROM notifications
WHERE user_id = ?
AND is_read = 0
AND delivery_method = 'in_app'
ORDER BY created_at DESC;

-- Queue email notifications
SELECT n.*, u.email, u.name
FROM notifications n
JOIN users u ON n.user_id = u.user_id
WHERE n.delivery_method = 'email'
AND n.delivery_status = 'pending';

-- Mark notifications as read
UPDATE notifications
SET is_read = 1
WHERE user_id = ?
AND notification_id IN (?, ?, ?);

-- Notification delivery stats
SELECT
    notification_type,
    delivery_method,
    COUNT(*) as total,
    COUNT(CASE WHEN delivery_status = 'sent' THEN 1 END) as sent,
    COUNT(CASE WHEN delivery_status = 'failed' THEN 1 END) as failed
FROM notifications
WHERE created_at >= datetime('now', '-7 days')
GROUP BY notification_type, delivery_method;

================================================================================
SECTION 5: FEEDBACK & MODERATION TABLES
================================================================================

--------------------------------------------------------------------------------
19. REVIEWS TABLE
--------------------------------------------------------------------------------
Purpose: User ratings and feedback system with moderation capabilities

Schema:
CREATE TABLE reviews (
    review_id INTEGER PRIMARY KEY AUTOINCREMENT,
    booking_id INTEGER NOT NULL REFERENCES bookings(booking_id) ON DELETE CASCADE,
    resource_id INTEGER NOT NULL REFERENCES resources(resource_id) ON DELETE CASCADE,
    reviewer_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
    comment TEXT,
    is_visible BOOLEAN NOT NULL DEFAULT 1,
    flagged_count INTEGER DEFAULT 0,
    host_response TEXT,
    host_responded_at DATETIME,
    helpful_count INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME
);

Columns:
- review_id: Unique identifier, auto-incremented
- booking_id: Link to completed booking
- resource_id: Resource being reviewed
- reviewer_id: User who wrote review
- rating: 1-5 star rating
- comment: Optional text review
- is_visible: Visibility flag for moderation
- flagged_count: Times reported by users
- host_response: Resource owner's response
- host_responded_at: Response timestamp
- helpful_count: Upvotes from other users
- created_at: Review creation timestamp
- updated_at: Last edit timestamp

Primary Key: review_id
Foreign Keys:
- booking_id ‚Üí bookings(booking_id) ON DELETE CASCADE
- resource_id ‚Üí resources(resource_id) ON DELETE CASCADE
- reviewer_id ‚Üí users(user_id) ON DELETE CASCADE

Indexes:
- idx_reviews_resource ON reviews(resource_id)
- idx_reviews_user ON reviews(reviewer_id)

Business Logic:
- One review per booking
- Only completed bookings can be reviewed
- Visibility controlled by moderation
- Host can respond once to each review
- Auto-hide if flagged_count exceeds threshold

Example Queries:
-- Get reviews for a resource
SELECT r.*,
       u.name as reviewer_name,
       u.profile_image as reviewer_image
FROM reviews r
JOIN users u ON r.reviewer_id = u.user_id
WHERE r.resource_id = ?
AND r.is_visible = 1
ORDER BY r.helpful_count DESC, r.created_at DESC;

-- Calculate resource rating
SELECT
    AVG(rating) as avg_rating,
    COUNT(*) as review_count,
    COUNT(CASE WHEN rating = 5 THEN 1 END) as five_star,
    COUNT(CASE WHEN rating = 4 THEN 1 END) as four_star,
    COUNT(CASE WHEN rating = 3 THEN 1 END) as three_star,
    COUNT(CASE WHEN rating = 2 THEN 1 END) as two_star,
    COUNT(CASE WHEN rating = 1 THEN 1 END) as one_star
FROM reviews
WHERE resource_id = ?
AND is_visible = 1;

-- Get reviews needing moderation
SELECT r.*, res.title as resource_title
FROM reviews r
JOIN resources res ON r.resource_id = res.resource_id
WHERE r.flagged_count >= 3
AND r.is_visible = 1
ORDER BY r.flagged_count DESC;

-- Add host response
UPDATE reviews
SET host_response = ?,
    host_responded_at = datetime('now')
WHERE review_id = ?;

--------------------------------------------------------------------------------
20. CONTENT_REPORTS TABLE
--------------------------------------------------------------------------------
Purpose: User-generated content reporting system for moderation

Schema:
CREATE TABLE content_reports (
    report_id INTEGER PRIMARY KEY AUTOINCREMENT,
    reporter_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    target_type TEXT NOT NULL CHECK (target_type IN ('review','message','resource','user')),
    target_id INTEGER NOT NULL,
    reason TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'open' CHECK (status IN ('open','in_review','resolved','dismissed')),
    resolved_by INTEGER REFERENCES users(user_id),
    resolved_at DATETIME,
    resolution_notes TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

Columns:
- report_id: Unique identifier, auto-incremented
- reporter_id: User who filed report
- target_type: Type of content reported
- target_id: ID of reported content
- reason: Explanation for report
- status: Report processing status
- resolved_by: Admin who resolved report
- resolved_at: Resolution timestamp
- resolution_notes: Admin notes on resolution
- created_at: Report creation timestamp

Primary Key: report_id
Foreign Keys:
- reporter_id ‚Üí users(user_id) ON DELETE CASCADE
- resolved_by ‚Üí users(user_id)
Indexes: Automatic on foreign keys

Business Logic:
- Polymorphic target (review, message, resource, user)
- Status workflow: open ‚Üí in_review ‚Üí resolved/dismissed
- Admin review queue based on status
- Track resolution for accountability

Report Reasons:
- Inappropriate content
- Spam or advertisement
- Harassment or bullying
- False information
- Copyright violation
- Safety concern

Example Queries:
-- Get pending reports for admin review
SELECT cr.*, u.name as reporter_name,
       CASE
         WHEN cr.target_type = 'review' THEN 'Review #' || cr.target_id
         WHEN cr.target_type = 'message' THEN 'Message #' || cr.target_id
         WHEN cr.target_type = 'resource' THEN (SELECT title FROM resources WHERE resource_id = cr.target_id)
         WHEN cr.target_type = 'user' THEN (SELECT name FROM users WHERE user_id = cr.target_id)
       END as target_description
FROM content_reports cr
JOIN users u ON cr.reporter_id = u.user_id
WHERE cr.status IN ('open', 'in_review')
ORDER BY cr.created_at;

-- Report statistics
SELECT
    target_type,
    COUNT(*) as total_reports,
    COUNT(CASE WHEN status = 'resolved' THEN 1 END) as resolved,
    COUNT(CASE WHEN status = 'dismissed' THEN 1 END) as dismissed,
    AVG(CASE WHEN resolved_at IS NOT NULL
        THEN (julianday(resolved_at) - julianday(created_at)) * 24
    END) as avg_resolution_hours
FROM content_reports
WHERE created_at >= datetime('now', '-30 days')
GROUP BY target_type;

-- Create a report
INSERT INTO content_reports (reporter_id, target_type, target_id, reason)
VALUES (?, 'review', ?, 'Inappropriate language and harassment');

-- Resolve a report
UPDATE content_reports
SET status = 'resolved',
    resolved_by = ?,
    resolved_at = datetime('now'),
    resolution_notes = 'Content removed and user warned'
WHERE report_id = ?;

================================================================================
DATABASE RELATIONSHIPS SUMMARY
================================================================================

USER RELATIONSHIPS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    users    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ owns resources (owner_type='user')
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îú‚îÄ‚îÄ creates groups
       ‚îÇ             ‚îú‚îÄ‚îÄ makes bookings
       ‚îÇ             ‚îú‚îÄ‚îÄ writes reviews
       ‚îÇ             ‚îú‚îÄ‚îÄ sends/receives messages
       ‚îÇ             ‚îú‚îÄ‚îÄ receives notifications
       ‚îÇ             ‚îî‚îÄ‚îÄ files content reports
       ‚îÇ
       ‚îî‚îÄ‚îÄ belongs to department

GROUP RELATIONSHIPS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   groups    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ owns resources (owner_type='group')
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

RESOURCE RELATIONSHIPS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  resources  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ has multiple images
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îú‚îÄ‚îÄ has equipment associations
       ‚îÇ             ‚îú‚îÄ‚îÄ has availability rules
       ‚îÇ             ‚îú‚îÄ‚îÄ has unavailable slots
       ‚îÇ             ‚îú‚îÄ‚îÄ generates analytics
       ‚îÇ             ‚îú‚îÄ‚îÄ receives bookings
       ‚îÇ             ‚îî‚îÄ‚îÄ receives reviews
       ‚îÇ
       ‚îî‚îÄ‚îÄ belongs to category

BOOKING RELATIONSHIPS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  bookings   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ has approval actions
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îú‚îÄ‚îÄ generates reviews
                     ‚îî‚îÄ‚îÄ links to message threads

COMMUNICATION FLOW:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ message_threads  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ contains messages
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ has participants
                               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ    messages      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  notifications   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ sent to users
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

================================================================================
PERFORMANCE OPTIMIZATION NOTES
================================================================================

CRITICAL INDEXES:
1. idx_bookings_dates - Essential for conflict detection
2. idx_resources_status - Filters published resources
3. idx_notifications_user - User notification queries
4. idx_messages_thread - Thread message retrieval

QUERY OPTIMIZATION TIPS:
1. Use covering indexes for frequently accessed columns
2. Denormalize read-heavy data (e.g., images, rules in resources)
3. Aggregate analytics data nightly, not real-time
4. Paginate large result sets
5. Cache resource availability calculations

SCALABILITY CONSIDERATIONS:
1. Partition large tables by date if needed
2. Archive old bookings after 1 year
3. Implement read replicas for analytics
4. Use queue for notification delivery
5. Consider NoSQL for message storage at scale

================================================================================
SECURITY CONSIDERATIONS
================================================================================

AUTHENTICATION & AUTHORIZATION:
- Passwords stored as bcrypt hashes only
- Email verification required for accounts
- Password reset tokens expire after 1 hour
- Role-based access control (student/staff/admin)
- Resource ownership validation

DATA PROTECTION:
- CASCADE DELETE maintains referential integrity
- RESTRICT DELETE prevents data orphaning
- Audit trail via booking_approval_actions
- Soft delete via status fields (not hard delete)

INPUT VALIDATION:
- CHECK constraints on enums
- Date range validation (end > start)
- Rating bounds (1-5)
- Capacity must be positive or NULL

PRIVACY:
- User data deletion cascades properly
- Message threads preserve on user delete (SET NULL)
- Anonymous analytics aggregation
- PII access logging recommended

================================================================================
MAINTENANCE PROCEDURES
================================================================================

DAILY TASKS:
1. Aggregate resource_analytics from bookings
2. Process notification delivery queue
3. Update booking status (pending ‚Üí expired if past)
4. Clean expired verification tokens

WEEKLY TASKS:
1. Archive completed bookings older than 90 days
2. Analyze slow queries and optimize
3. Review flagged content (reviews with high flagged_count)
4. Generate utilization reports

MONTHLY TASKS:
1. Vacuum database to reclaim space
2. Rebuild indexes for performance
3. Archive old notifications
4. Review and update resource availability rules

DATABASE BACKUP:
- Full backup: Daily at 2 AM
- Incremental: Every 4 hours
- Retention: 30 days
- Test restore: Weekly

================================================================================
MIGRATION NOTES FROM V1.0 TO V2.0
================================================================================

REMOVED TABLES (11 tables):
The following tables were removed as they were not used in the application:

1. admin_logs - Admin audit functionality not implemented
2. ai_interactions - AI features descoped from current release
3. booking_recurrences - Recurring bookings not implemented
4. calendar_events - External calendar sync not implemented
5. csrf_tokens - CSRF handled by Flask-WTF at app level
6. external_calendar_accounts - Calendar integration descoped
7. group_members - Simplified group model without membership
8. rate_limits - Rate limiting via nginx/cloudflare
9. search_queries - Search analytics not implemented
10. uploaded_files - File tracking not implemented
11. user_sessions - Session management via Flask-Session

SCHEMA IMPROVEMENTS:
- Added indexes for performance
- Denormalized frequent joins (images, rules)
- Simplified polymorphic relationships
- Removed unnecessary complexity

DATA MIGRATION:
- All active data preserved in remaining 20 tables
- No data loss for implemented features
- Foreign key constraints maintained

================================================================================
END OF DOCUMENTATION
================================================================================
Database: campus_resource_hub.db
Tables: 20 (optimized from 31)
Indexes: 14 user-defined + automatic indexes
Version: 2.0 (Production-ready schema)
Last Updated: November 15, 2025
================================================================================